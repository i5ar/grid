<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="isometric grid generator">
	<title>isometric grid generator</title>
	<link rel="stylesheet" type="text/css" href="css/stylesheet.css" />
	<script type="text/javascript">

		const oElement = document.documentElement;
		const oCanvas = document.createElement('canvas');
		const oContext = oCanvas.getContext("2d");

		function updateGrid() {
			const gridSettingsElement = document.getElementById('settings');

			const cellHeightElement = gridSettingsElement['cell-height'];

			const lineWidthElement = gridSettingsElement['line-width'];
			const strokeStyleElement = gridSettingsElement['stroke-style'];

			const cellHeight = parseInt(cellHeightElement.value, 10);
			const cellWidth = cellHeight * Math.sqrt(3);

			const lineWidth = parseInt(lineWidthElement.value, 10);

			const strokeStyle = strokeStyleElement.value;

			gridSettingsElement.querySelector("label[for='cell-height'] span").innerHTML = cellHeight;
			gridSettingsElement.querySelector("label[for='line-width'] span").innerHTML = lineWidth;
			gridSettingsElement.querySelector("label[for='stroke-style'] span").innerHTML = strokeStyle;

			oCanvas.setAttribute('width', cellWidth);
			oCanvas.setAttribute('height', cellHeight);

			oContext.clearRect(0, 0, cellWidth, cellHeight);

			oContext.strokeStyle = strokeStyle;
			oContext.lineWidth = lineWidth;

			oContext.beginPath();
			oContext.moveTo(cellWidth / 2, 0);
			oContext.lineTo(0, cellHeight / 2);
			oContext.lineTo(cellWidth / 2, cellHeight);
			oContext.lineTo(cellWidth, cellHeight / 2);
			oContext.lineTo(cellWidth / 2, 0);
			oContext.lineTo(cellWidth / 2, cellHeight);
			oContext.moveTo(cellWidth, 0);
			oContext.lineTo(cellWidth, cellHeight);
			oContext.moveTo(0, 0);
			oContext.lineTo(0, cellHeight);
			oContext.stroke();

			oElement.style.backgroundImage = 'url("' + oCanvas.toDataURL() + '")';
		}

		function downloadCell() {
			const link = document.createElement('a');
			link.download = 'isometric.png';
			link.href = oCanvas.toDataURL()
			link.click();
		}

		function printGrid() {
			window.print();
		}
	</script>
</head>

<body onload="updateGrid();">

	<main id="sketch-holder">

		<canvas id="canvas" class="canvas"></canvas>
	</main>

	<aside>
		<div class="draw">
			<input type="button" class="line" id="polyline" value="polyline">
			<input type="button" id="polygon-magenta" value="polygon xz" class="solid magenta">
			<input type="button" id="polygon-cyan" value="polygon yz" class="solid cyan">
			<input type="button" id="polygon-yellow" value="polygon xy" class="solid yellow">
		</div>
		<div class="edit">
			<input type="button" id="remove" value="remove" class="solid gray">
		</div>

		<!-- <div id="debug">double click to end polyline or close polygon</div> -->
	</aside>

	<form id="settings">

		<label for="cell-height">cell height<span></span></label>
		<input type="range" id="cell-height" value="64" name="cell-height" min="10" max="200" oninput="updateGrid();" />

		<label for="line-width">line width<span></span></label>
		<input type="range" id="line-width" value="1" name="line-width" min="1" max="20" oninput="updateGrid();" />

		<label for="stroke-style">stroke style<span></span></label>
		<input type="color" id="stroke-style" value="#888888" name="stroke-style" oninput="updateGrid();" />

		<!-- <input type="button" value="download" onclick="downloadCell();" /> -->

		<input type="button" value="print" onclick="printGrid();">

	</form>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.3.1/fabric.min.js"></script>
	<script>
		// https://stackoverflow.com/questions/58711027/draw-a-straight-line-between-two-points-selected-in-a-mouse-down-event

		//revised 3/2/2021 - switched splice() to mousedown
		// https://codepen.io/Rstewart/pen/ZEBORxN
		var canvas, obj, polyline, mouseDown = false, pts = [], lastPt = 1, polyType = 'Polyline', polyBtn, poly = false, bgColor, sColor, spessore, id = -1;

		$(document).ready(function () {
			canvas = new fabric.Canvas($('canvas')[0], { objectCaching: false });

			canvas.setHeight(window.innerHeight);
			canvas.setWidth(window.innerWidth);

			canvas.on('mouse:down', function (e) {
				if (poly == true) {
					if (pts.length > 1) { pts.splice(-1, 1); } //remove duplicate start points
					polyline = new fabric.Polyline(pts, {
						objectCaching: false, name: 'temp', fill: '', stroke: sColor, strokeWidth: 4,
						originX: 'center', originY: 'center', selectable: false
					});

					// NOTE: Snap to grid using the nearest multiple instead of mouse.y and mouse.x.
					const gridSettingsElement = document.getElementById('settings');
					const cellHeightElement = gridSettingsElement['cell-height'];
					const cellHeight = parseInt(cellHeightElement.value, 10);
					const cellWidth = cellHeight * Math.sqrt(3);
					const gridModuleX = Math.floor(cellWidth/2);
					const gridModuleY = cellHeight/2;
					const nearestMultiple = (n, gridModule) => Math.round(n / gridModule) * gridModule;
					const nearestX = nearestMultiple(mouse.x, gridModuleX);
					const nearestY = nearestMultiple(mouse.y, gridModuleY);

					canvas.add(polyline); polyline.points[pts.length] = { x: nearestX, y: nearestY }; lastPt++; mouseDown = true;
					// $('#debug').text(JSON.stringify(pts));

				} else {
					// NOTE: Make all objects selectable while not drawing.
					canvas.getObjects().map(obj_ => obj_.selectable = true);
				}
			});

			canvas.on('mouse:move', function (e) {
				mouse = canvas.getPointer(e.e);
				if (poly == true && mouseDown) {
					polyline.points[lastPt - 1] = { x: mouse.x, y: mouse.y }; canvas.renderAll();
				}
			});

			canvas.on('mouse:dblclick', function (e) {
				canvas.forEachObject(function (obj) { if (obj.name == 'temp') { canvas.remove(obj); } });
				polyObj = new fabric[polyType](pts, {
					objectCaching: false, id: id++, fill: bgColor, stroke: sColor, strokeWidth: spessore,
					originX: 'center', originY: 'center', selectable: true
				});
				canvas.add(polyObj); poly = false; polyBtn = ''; lastPt = 1; mouseDown = false; pts = [];
				$('.draw input').removeClass('active');

			}); //end dblclick

			document.onkeydown = function (evt) {
				evt = evt || window.event;
				if (evt.key === "Delete") {
					canvas.remove(...canvas.getActiveObjects());
				} else if (evt.key === "Escape") {
					canvas.forEachObject(function (obj) { if (obj.name == 'temp') { canvas.remove(obj); } });
					polyObj = new fabric[polyType](pts.slice(0, -1), {
						objectCaching: false, id: id++, fill: bgColor, stroke: sColor, strokeWidth: spessore,
						originX: 'center', originY: 'center', selectable: true
					});
					canvas.add(polyObj); poly = false; polyBtn = ''; lastPt = 1; mouseDown = false; pts = [];
					$('.draw input').removeClass('active');
				}
			};

			canvas.on('selection:created', function () { obj = canvas.getActiveObject(); });
			canvas.on('selection:cleared', function () { obj = ''; });

			$('.draw input').on('click', function (e) {
				$('.draw input').removeClass('active');

				// NOTE: Make all objects not selectable while drawing.
				canvas.getObjects().map(obj_ => obj_.selectable = false);

				$(this).addClass('active'); polyBtn = $(this).attr('id');
				if (polyBtn == 'polyline') { polyType = 'Polyline'; poly = true; bgColor = ''; sColor = 'black'; spessore = 4; }
				if (polyBtn == 'polygon-magenta') { polyType = 'Polygon'; poly = true; bgColor = 'rgba(255,0,255,0.5)'; sColor = 'magenta'; spessore = 0;}
				if (polyBtn == 'polygon-cyan') { polyType = 'Polygon'; poly = true; bgColor = 'rgba(0,255,255,0.5)'; sColor = 'cyan'; spessore = 0;}
				if (polyBtn == 'polygon-yellow') { polyType = 'Polygon'; poly = true; bgColor = 'rgba(255,255,0,0.5)'; sColor = 'yellow'; spessore = 0;}
			});

			// NOTE: Remove object.
			document.querySelector('.edit input#remove').onclick = () => canvas.remove(...canvas.getActiveObjects());

		}); //end ready
	</script>
</body>

</html>